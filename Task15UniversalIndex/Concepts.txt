Концепции, лежащие в основе универсального индекса

Неизменяемый индекс IndexViewImmutable<Tkey> сделан как некоторая идейная основа. Он больше не используется, 
воспроизводятся лишь элементы решений. В дальнейшем, будем считать, что таблица и индекс обладают динамикой.
Соответственно, нужно доопределить опорную таблицу и базовое индексное построение необходимыми элементами.

К интерфейсу опорной таблицы надо добавить редактирующие изменения: добавление элемента и убавление элемента. 
Добавление в чем-то будет функционально дублировать Build, но это существенно другое действие. Убавления вообще
не было. Еще нам понадобится фильтр, убирающий из потока указателей на элементы таблицы, те из них, которые 
отмечены как уничтоженные. В дальнейшем, нам понадобится менеджер индексов, задача которого будет выполнять 
коррекцию всех индексов, при выполнении операции добавления (а может, и убавления?). Наверное, такой менеджер
нужно организовывать через событие (event). Пока этот момент пропустим. 

Теперь подумаем о спецификации индекса. Что изменяется при добавлении динамики? Как уже было зафиксировано,
индекс состоит из неизменяемой части и изменяемой (динамической) части. Неизменяемая часть (вроде) уже 
специфицирована. А изменяемая? Или общая? Вроде все то, что определено для неизменяемой, нужно и для изменяемой. 
Существенное добавление должно быть связано с отработкой операций редактирования. Хотя бы добавления элемента
в опорную таблицу. Что-то вроде OnAppendElement(...).

Main2() - это промежуточное решение, в котором создается опорная таблица через класс TableView, таблица 
заполняется данными. Далее, строится неизменяемый индекс, в данной программе - на строковую колонку. И наконец,
индекс тестируется на предмет получения данных. Разница в Main1() и Main2() в двух моментах. Первый - 
используется "боевой" вариант опорной таблицы и, второй - поиск ведется по расширенному на половину диапазону,
а значит, успешных нахождений - приблизительно 2/3 от 1000.

Следующее изменение каснется индекса. Теперь нужно сделать динамический индекс, который будет содержать 
динамическую таблицу (словарь) и неизменяемый индекс. И будет отрабатывать запросы. Делаю DynamicIndex.

Несколько запутался в переметрических типах и интерфейсах. Попробую проанализировать жизненный цикл универсальной
изменяемой таблицы с индексами. Вначале создается коннектор, который либо дает подсоединение к существующей опорной 
таблице, либо ее создает и дает к ней подсоединение. Не обеспечивается фукнциональная полнота таблицы, если она
не заполнена данными. (??? - может все-таки обеспечить?). По имеющейся индексной логике, индекс можно создать в 
когда он потребуется и можно уничтожеть, когда надобность в нем отпадет. С точки зрения подключения к базе данных,
индекс - ячейка, но по ячейке восстановить особенности устройства индекса не видно как. Так что оставим задачу
управления индексами за потребителем таблицы или базы данных. Что это означет? Когда мы коннектимся, мы должны знать
особенности индексов, которые создавались ранее. Получается, что надо коннектиться и к индексам. Возможюно, проверяя
наличие файла (ов), но не более того. Итак, программа запущена, выполняем Connect. Если базы данных еще нет, создаем 
пустышку. Коннектимся к базе данных. Теперь можно ее построить Build(), т.е. заполнить начальными данными. Пока будем
считать Build - однократным действием, всегда начинающимся с очистки Clear() базы данных. С данной таблицей уже можно:
1) Перебрать неуничтоженные элементы; 2) Добавить элемент; 3) Уничтожеть элемент. Вполне приличная себе 
функциональность...     

Но (в смысле "и"!), к опорной таблице можно приделывать индексы и можно их убирать. Соответственно, индекс может уже
существовать или еще нет. К нему также надо "коннектиться". В принципе, это можно сделать с вух сторон. Либо создать 
индекс, указав опорную таблицу, либо каким-нибудь методом CreateIndex(), работающим от таблицы. Второе кажется не 
очень хорошо, поскольку пока для создания индекса надо много что указать, в том числе тип. Пойдем по первому пути.
Что-нибудь вроде имеющегося: 
IIndexImmutable<string> s_index = new IndexViewImmutable<string>(path + "s_index")
   {
      Table = table,
      KeyProducer = va => (string)((object[])(((object[])va)[1]))[0]
   };
Генератор ключа выглядит ужасно, но пока именно так...
Соответственно, создание индекса может сделать отметку в таблице. И тогда таблица начнет отрабатывать редактирующие
операторы: Clear(), Build(), AppendValue(), Delete...
Естественно, связь индекса с таблицей не прерывается и прямо индекс можно сделать Drop() или Remove(). Вроде все 
склеивается.

Устроив интерфейсы и приведя имеющиеся решения к этим интерфейсам, пора сделать новую реализацию опорной таблицы
и индексов. Для этого, запускающую программу сменю на Main3(). Буду делать TableView и DinamicIndexUnique. Возможно, 
в дальнейшем, уникальность ключевого значения будет задаваться булевским параметром.

Сделал небольшие модификации в оперной таблице TableView, необходимые для включения индексов в работу таблицы. Теперь
надо порассуждать о включаемом индексе. Я такой сейчас готовлю: DynamicIndexUnique<Tkey, IndexImmut>. Он получается
аж с двумя параметрами, это не считая возможных других, в дальнейшем. Параметр типа ключа - обычный. Но также задается
параметр неизменяемого индекса для задания индексного массива. По нашей идее он неизменяемый до следующего 
переформирования. Предположим, индексный массив задается "снаружи" и "прилепляется" через свойство. В этом могут быть
некотрые проблемы из-за "разбегания" генератора ключа (будет определяться дважды). Но посмотрим...

20150331 11:07
Удалось собрать базовое решение. То есть: 1) опорная таблица содержит не только себя, но и ссылки на активированные 
индексы. Это позволит автоматически отслеживать изменения в таблице, делая изменения в индексах. 2) Индексный массив
простой (будут и другие решения) и неизменяемый. 3) Индекс объединяет словарь входов и индексный массив. Испытания
пока подтверждают ранее достигнутые результаты. 

Следующие шаги:
а) Сделать вариант индекса, не являющегося Unique. 
б) Проверить работу индекса на целых значениях.
в) Внедрить понятие "выровненное ключевое значение" и реализовать индекс в виде пары {offset, key_value}.
г) Внедрить понятие "полуключ" и реализовать индекс в виде аналогичной пары.
д) Внедрить понятие "шкала" и добавить шкалу в реализации.

 Пункт а) попробую сделать "дешево" - введу параметр unique в инициализацию индекса.

20150403 12:07
Сделал через параметр unique, вроде без потери простоты реализации. Теперь пришло соображение о моменте,
который я не учитывал. Дало в том, что основные рассуждения насчет поиска касаются поиска первого или всех
тех, ключевое значение которых совпадает с образцом. Но существует и другая поисковая ситуация. Надо найти
первый или всех таких, которые соответствуют нулю при задании уровня глубины. 

20150404 09:12
Так вчера и не смог напрячься на созидательную работу. Сегодня - полон решимости, надо действовать. 

Момент, который является принципиальным и который я продумывал - другая схема выполнения поиску - поиск 
по функции "глубины". То есть, на каком-то уже построенном индексе задается функция, отображающая элементы
опорной таблицы в числа по принципу: 0 - "поверхность", '+' - значения "больше" заданного порога, '-' - 
значения "меньше" порога. Связь с уже построенным инексом с том, что функция должна быть согласованной с
функцией ключа и с заданным на ключах отношением сравнения. Частным, но не единственным вариантом такой 
фукнции уровня будет что-то вроде: 
Func<Tkey, int> Level = key => key.CompareTo(key0);
Соответственно, поиск по функции уровня должен выдавать все значения (или первое значение), такие, что 
функция уровня на них равна нулю. Согласованность функции уровня с конкретным индексом позволяет 
воспользоваться бинарным поиском на этом индексе. В указанном частном случае, поиск по функции уровня 
совпадает с поиск значений с заданным ключем. Но в общем случае, этот поиск дает более широкое множество
значение, соответствующих "соседним" ключам, "неразличимым" в метрике уровнего поиска. Согласованность
функции уровня с индексом обеспечивает (долна обеспечивать) непрерывный характер, т.е. интервал, для этого 
более широкого множества.

Существенная проблема появляется при появлении слабой динамики. Статическая часть индекса, для которого 
определен (нетривиальный) поиск по уровню, т.е. индексный массив, хорошо соответствуют задаче и бинарный
поиск выполняется хорошо. А вот словарь, накапливающий пары ключ-оффсет или ключ-множествооффсетов, уже 
плохо соответствуют.   
			  
Возможно, если несколько модифицировать уровневый подход, можно и всю конструкцию грамотно изложить. Но 
пока не получается. Идея рассмотрния следующая: есть единый индекс с последовательным упорядочиванием 
по одному полю, потом по другому, потом по третьему. Ключ, в данном случае становится весьма композитным -
что-то вроде кортежа из трех значений. И для базовой ситуации, когда задается ключ полностью, т.е. в
данном случае в виде значений трех полей, все ранние ключевые построения "работают". Но если захотеть 
сделать выборку по значению неполностью заданного ключа, напр. если заданы первые два поля, то мы 
приходим к ситуацией, названной в данном разделе "поиск по функции уровня". Для функции уровня, "работает"
только бинарный поиск. да и то, только в индексном массиве. А словарь придется перебирать поэлементно. 
Можно предположить, что при другом способе задания поискового критерия, возможно в виде каких-то 
факторизаций, может появится более экономная и эффективная теория. По крайней мере стоит заметить, что
вот этих уровневых функций может быть много. У одного заданного индекса.

Подход, который я попытался наметить в предыдущем абзаце, можно было бы назвать чем-нибудь вроде "ступенчатое
индексирование". Тут есть над чем работать, но это потом. Сейчас попробую зафиксировать поиск по функции
глубины.

20150405 10:32
Я все думаю о ступенчатом индексировании. Не очень получается, но явно что-то в этом есть. Итак, пусть есть
цепочка функций, удовлетворяющих условиям ключевого индексного использования. Например, это могут быть 
целочисленные коды. Используем их для пострения индекса следующим образом: упорядочивание идет по первому  
коду, при равенстве, используется второй и т.д. Идея, которую мы хотим проявить, заключается в том, что
пи таком упорядочивании эффективно решается задача поиска по первому коду, по первому и второму и т.д.
Обычным делением отрезка пополам. 

Теперь мы сделаем "трюк". Мы выделим случаи, когда для одного значения первого ключа имеется слишком много 
вариантов. Эти случаи мы выстроим в пары: значениепервогоключа-индекс2. Где индекс2, это также цепочечный 
индекс, но с цепочкой ключ2-ключ3-... Тогда при поиске по первому ключу, надо будет проверять нет ли по 
этому значению частного варианта и если есть, он сразу даст решение. Если идет поиск по первому и второму
ключу, при совпадении первого ключа с частным случаем, производится поиск в индексе найденной пары. 
Метод рекурсивно продолжается. 

Пока мы при поиске выигрываем ТОЛЬКО в потенциальной быстроте нахождения частного случая. Потому что в 
остальном, поиск базируется на дихотомии. Но если подключить шкалирование, то ситуация несколько другая. 
При шкалировании, нахождение первого диапазона будет произовдиться одинаково, грубо говоря - за одно 
обращение. А вот для частного случая мы также можем организовать шкалу и на этом существенно выиграть. 

А что у нас в шкале? Там индексом отмечается ячейка, содержащая диапазон для данных значений индексного 
(?) ключа. А как это сочетается с цепочечной индексацией. Пусть код индексного ключа является 
конкатенацией и обрезанием кодов цепочки. Нет уверенности в равномерной плотности таких модифицированных 
кодов. 

Теперь пора работать конструктивно. Во-первых, намечу или даже реализую поиск по фукции уровня. Сейчас
наличие его не существенно, но чтобы не висел...

А что существенно, так это перенести наработку индексов с ключами/полуключами в данный пакет.
Попробую разделить варианты ключа и полуключа. 

Как промежуточный этап, я сделал вариант стандартного индекса на целочисленную колонку: Main4(). Вроде
заработал, время похоже на правду: 314-324

Теперь сделаю индекс с ключем - IndexKeyImmutable. Теперь попробую применить для целочисленной колонки

20150406 07:47
Теперь, аналогично, попробую сделать IndexHalfkeyImmutable.

20150407 07:56
Полуключ также сделал и вроде он работает. Теперь надо сделать шкалу. Попробую организовать это дело
так: шкала будет классом, собственно массив может быть построен по запросу, класс приклепляется к
неизменяемому индексу и используется, если не null. Как-то так...

Пока не ясно как формировать в шкале границы диапазона. В принципе, если исходить из формирования
шкалы на основе минимального и максимального значений, вопросом является как их вычислять. Можно 
это делать при формировании значения шкалы, но одним проходом будет меньше если вычислять...
Сейчас сообразил, что есть более простой способ определения минимального и максимального. Надо 
просто посмотреть в первый элемент базового индекса и в последний. Индексный массив же ОТСОРТИРОВАН!

20150409 09:52
Исправил ошибки и заставил шкалу работать. Иногда получается эффектно (15-40 мс. на тусячу запросов).
Собственно, при данной схеме существенно быстрее уже не получится, потому что такие величины означают 
то, что делается разовое количество обращений к диску. 

Сегодня сообразил простую вещь, в шкале нет необходимости хранить количество (number), достаточно 
хранить только индекты начал (start). Это потому, что количество легко получается вычитанием соседних 
стартовых номеров. А это дефицитная память...  
 
Проведенные эксперименты показали, что эффективность шкалы может быть почти предельная при существенно 
меньших размерах, чем полное для индекса число элементов. Этот оптимум между скоростью и размером
шкалы я устанавливаю в 1-2%. Сейчас, дефолтное значение шкалы буду вычислять как размер индексного
массива, деленный на 64. 

Теперь надо переименовать шкалу в ScaleMemory и сделать ScaleCell. Но сначала, уменьшу раз0мер шкалы 
вдвое убрав оттуда number. 

20150410 04:51
Несколько не удовлетворен организацией встраивания шкалы в неизменяемый индекс. Но, в принципе, это 
сделано и, похоже, работает. Не доделанными являются операции редактирования. Более высокий уровень 
требований - в том, чтобы автоматически перевычислялись индексы в фоновом режиме. И еще чтобы аккуратнее
решались вопросы разогрева. Мысль по этому поводу такая: произошел "холодный" запуск, система, хоть и 
не быстро (100 доступов в сек.), но начинает выполнять запросы. Одновременно, запускается первый уровень 
"разогрева" и выполняется в фоновом режиме. После выполнения первого разогрева, можно помечтать о 
следующем уровне, когда структуры более "жестко" переводятся в оперативную память. Пока подобной 
универсальной схемы не найдено, но мысли брезжут...

Рассуждая о последнем упомянутом моменте, появилось такое соображение: Можно статические ячейки, а их, 
как правило немало, переводить на потоки байтов. То есть, берешь ячейку, узнаешь ее размер в байтах и 
заводишь массив байтов соответствующего размера и копируешь одно в другое. А потом переключаешься с 
базовой ячейки на временно созданную. Не совсем понятно как переключаться в динамике работы системы. 
Но что-то в этих идеях есть... Надо бы попробовать соорудить копию ячейки в оперативной памяти и
померить ее характеристики. 



 

  
 


 




   


