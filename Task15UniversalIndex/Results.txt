Результаты прогона тестов

Простой индексна статических данных, рабочий компьютер, 1 млн. записей, индекс на строку
Загрузка 389, Построение индекса 2632, 1000GetAllByKey 223

Домашний компьютер, 1 млн. записей, индекс на строку
Загрузка 1291, Построение индекса 5222, 1000GetAllByKey 433 (А обычно, разница бывает в 2.5 раза!)

Рабочий компьютер. 100 тыс. записей. Main2(). Загрузка 50, Построение индекса 229, 1000GetAllByKey 94
Рабочий компьютер. 1 млн. записей. Загрузка 487, Построение индекса 2755, 1000GetAllByKey 138

Домашний компьютер, 1 млн. записей, Main2()
Загрузка 1650, Построение индекса 7089, 1000GetAllByKey 409 (только 2-е измерение в 2.5 раза, другие - больше!)
Загрузка 842, Построение индекса 5438, 1000GetAllByKey 403 (cnt=643, т.е. приблизительно 2/3 поисков успешны)
Загрузка 845, Построение индекса 5526, 1000GetAllByKey 366 (cnt=663, т.е. приблизительно 2/3 поисков успешны)

Получил первый нетривиальный результат в новой системе. Таблица TableView, индекс DynamicIndexUnique, 
индексная таблица IndexViewImmutable:
Домашний компьютер, 100 тыс записей. Загрузка 87, индекс 87, 1000GetAllByKey 269 (cnt=668)
Домашний компьютер, 1 млн записей. Загрузка 818, индекс 5320, 1000GetAllByKey 390 (cnt=661)
Рабочий компьютер, 1 млн записей. Загрузка 462, индекс 2891, 1000GetAllByKey 144 (cnt=670)
Предыдущее, без загрузки, 1000GetAllByKey 190 (cnt=654)
Включение Warmup по индексному массиву, дает 180. Warmup() по опорной таблице почти не дает улучшения: 178
Новая проверка дала 135-138 - вполне неплохо...
Домашний компьютер, 1 млн записей. Загрузка -, индекс -, 1000GetAllByKey 341 (cnt=661)
Домашний компьютер, 1 млн записей. Целый ключ. Загрузка 933, индекс 1984, 1000GetAllByKey 324 (cnt=684), без загрузки 315
Домашний компьютер, 100 тыс записей. IndexKeyImmutable: Загрузка 87, индекс 177, 1000GetAllByKey 108 (cnt=678)
Домашний компьютер, 1 млн записей. IndexKeyImmutable: Загрузка 889, индекс 1973, 1000GetAllByKey 156 (cnt=650)
Домашний компьютер, 100 тыс записей. IndexHalfkeyImmutable, строки: Загрузка 88, индекс 371, 1000GetAllByKey 133 (cnt=672)
Домашний компьютер, 1 млн записей. IndexHalfkeyImmutable: Загрузка 873, индекс 4063, 1000GetAllByKey 182 (cnt=668)
Домашний компьютер, 100 тыс записей. IndexKeyImmutable+Scale(10000): Загрузка 87, индекс 208, 1000GetAllByKey 34 (cnt=652), минимально 15 мс. при 100000 
Домашний компьютер, 1 млн записей. IndexKeyImmutable+Scale(10000): Загрузка 978, индекс 2522, 1000GetAllByKey 58 (cnt=686), минимально 20 мс. при 1000000 
Домашний компьютер, 1 млн записей. IndexKeyImmutable+Scale(auto): Загрузка 866, индекс 2206, 1000GetAllByKey 19 (cnt=630), при auto - длина шкалы совпадает с длиной индексного массива
Ура! Вроде заработало!
Домашний компьютер, 100 тыс записей. IndexHalfkeyImmutable+Scale(10000), строки: Загрузка 94, индекс 396, 1000GetAllByKey 56 (cnt=663)
Домашний компьютер, 100 тыс записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 91, индекс 393, 1000GetAllByKey 50 (cnt=655)
Домашний компьютер, 1 млн записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 847, индекс 4503, 1000GetAllByKey 64 (cnt=690)
А вот для 10 млн. результаты совсе даже не очень: 9120, 149549, 54207 (cnt=664) Еще раз:
21659б 82514, 101101 (676) - как-то плохо... Надо разбираться.
Абсолюно тот же тест дал на рабочем компьютере результаты:
Рабочий компьютер, 10 млн. записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 4851, индекс 33729, 1000GetAllByKey 27 (cnt=670)
Попробую 100 млн., наверное будут проблемы 32-разрядности
Так и есть. Попробую скомпилировать под 64 разряда
Удивительно, но все прошло гладко:
Рабочий компьютер, 100 млн. записей. IndexHalfkeyImmutable+Scale(auto), строки: Загрузка 42015, индекс 397043, 1000GetAllByKey 7668 (cnt=673)
Вопрос: почему "проседает" производительность доступа? Может из-за выхода за пределы кеширования?
======= Домашний
Провожу эксперимент: Работаю с 5 млн. записей, индексирование строки, с получлечем и шкалой. Меняю размер шкалы:
2 млн. 90-100 мс.
3 млн. 75 мс.
4 млн. 74 мс.
5 млн. 72 мс.
2 млн. 74 мс.
1 млн. 73 мс.
500 тыс. 75 мс.
10 тыс. 98 мс.
Без Scale 219 мс.
100 тыс.  77 мс.
1 тыс. 122 мс.
50 тыс. 83 мс.
75 тыс. 78 мс.
Промежуточный вывод: можно ограничиться 50-100 тыс., т.е. фактором 1-2% 
======= Рабочий
Для контроля, повторю эксперимент:
75К - 35
no Scale - 87 
1K - 51
10K - 40
50K - 36
75K - 33
100K - 34
200K - 33
500K - 33
1M - 32
2M - 31
5M - 31
Все подтверждается, поэтому можно установить дефолтный определитель размера шкалы 

Реализовал ячеечный вариант шкалы. ПРовел расчет на таблице из 100 млн. на строковом столбце и полуключем и шкалой.
При созданиии базы данных получилось: 39337, 357681, 79 (667)
При коннекшине: 10 сек. разогрев и 76 мс. Выполнение 1000 запросов 
Разогрев все же дольше, секунд 32. 








 